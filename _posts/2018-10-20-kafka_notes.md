# kafka 生产者
几个关键流程
- brokers发现
- 序列化为字节数组并做压缩
- 消息批次
- 发送失败自动重试
- 发送模式：发送并忘记、同步发送、异步发送
- broker确认消息

## broker发现
**不需要**提供全部的brokers地址，kafka生产者可以从可用的brokers发现其他brokers，建议设置两个brokers，其中一个宕机时仍然可以连接到集群上

> 思考：是否可以定期刷新brokers，比如brokers集群配置有变化，最早发现的brokers地址无效（或者部分无效），通过重新发现来保持同步。或者由brokers集群主动通知生产者？

## 序列化和压缩
brokers接受字节数组，所以要把发送的对象序列化为字节。
消息发送默认不会压缩，可以指定 `compression.type = snappy|gzip|lz4` 进行压缩。
- snappy: google发明，占用较少CPU，可观的压缩比，比较关注性能和网络带宽可以考虑
- gzip: 占用较多CPU，提供更高的压缩比，适合网络带宽比较有限的情况
使用压缩可以降低网络和存储开销，这是kafka的主要瓶颈所在

## 消息批次
当有多个消息需要被发送到同一分区，会被放到同一个批次里，`batch.size` 定义了一个批次可以使用的内存大小（按字节），当批次满时该批次所有消息会被发送出去。但是并不是一定等批次满了才发送消息，所以`batch.size`设置得大了只会增加一些内存开销；设置得太小会导致消息被频繁发送出去。
`linger.ms` 参数则用来定义一个批次在发送出去前等待更多消息加入批次的时间
所以，生产者在批次填满或等待到达上限就会把批次的消息发送出去

本质上说，消息批次起到了类似 socket 缓冲区的作用。针对网络时延比较大的消息发送/接收，设置较大的缓冲区能够减少消息发送的网络开销，因为消息是一个批次一个批次发送的，批次还在网络中传输的时间正好可以用来累积消息数据，减少网络上传输的批次数量还能减少网络拥塞，但是这样也增加了消息传递的延迟

## 发送失败自动重试
通过设置 `retries` 重发次数，生产者在收到服务器临时错误时（网络抖动、分区找不到首领等），可以重发消息
默认每次重试会等待100ms，可以通过 `retry.backoff.ms` 来调试等待时长，不能太短，否则生产者会提前放弃重试，建议让总的重试时间（`retries * retry.backoff.ms`）比kafka集群恢复的时间长
由于有了自动重试，代码可以不用处理那些可重试的错误，只需要处理那些不可重试错误或者重试次数超出上限的情况

我们知道kafka可以保证分区内消息是有序的，即生产者按一定顺序发送消息，brokers会按这个顺序写入分区，消费者也按这个顺序读取。
但是如果设置了重试，则可能出现批次间乱序的问题，例如当 `max.in.flight.requests.per.connection > 1` 时，由于第一个批次发送失败，但是第二次批次可能写入成功，第一个批次被重试，两个批次顺序就反过来了。
将 `max.in.flight.requests.per.connection` 设置为 1，这样生产者尝试发送第一批消息时，就不会有其他消息发送给broker。但这样会严重影响生产者吞吐量，只有对消息顺序有严格要求时才这么做。将 `max.in.flight.requests.per.connection` 设置得较高会占用较多内存，因为同时需要为多个批次分配内存

> Q: 如果要保证生产者发送、broker写入分区、消费者读取的顺序均一致，即使没有发生重试，也需要设置 `max.in.flight.requests.per.connection = 1`才能达到？

## 发送模式
支持一下三种：
- 发送并忘记：业务代码不关心消息是否到达，大多数情况下消息会正常到达，而且生产者会自动尝试重发
- 同步发送：发送并返回一个future，调用future的`get`方法进行等待
- 异步发送：采用回调函数

参数 `acks` 指定了必须有多少个分区副本收到消息，生产者才会认为消息写入是成功的
- `acks == 0`: 生产者不等待服务器返回，也意味着生产者不会重试，会发生消息丢失，但是能够支持最大吞吐
- `acks == 1`: 生产者等待收到分区首领的响应，如果发生错误，生产者可以重试，但是如果发生首领重新选举且是一个没有收到消息的broker成为新首领，消息还是会丢失。采用同步发送模式，吞吐会比较受影响；采用异步发送模式，延迟问题可以得到缓解，但是还是会受到发送中消息数量的限制（`max.in.flight.requests.per.connection`、`buffer.memory`）

## 参考文章
![提高 Linux 上 socket 性能](https://www.ibm.com/developerworks/cn/linux/l-hisock.html)
![TCP的滑动窗口与拥塞窗口](https://blog.csdn.net/zhangdaisylove/article/details/47294315)
![tcp滑动窗口以拥塞窗口和各种缓冲的总结](https://blog.csdn.net/lishanmin11/article/details/77092652?utm_source=blogxgwz1)
